"use strict";(self.webpackChunkflash_list=self.webpackChunkflash_list||[]).push([[380],{2723:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"2.x","banner":null,"badge":true,"noIndex":false,"className":"docs-version-current","isLast":false,"docsSidebars":{"autoSidebar":[{"type":"link","label":"Introduction \ud83d\udcda","href":"/flash-list/docs/","docId":"introduction","unlisted":false},{"type":"category","label":"Fundamentals","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Usage","href":"/flash-list/docs/usage","docId":"fundamentals/usage","unlisted":false},{"type":"link","label":"Performance","href":"/flash-list/docs/fundamentals/performance","docId":"fundamentals/performance","unlisted":false},{"type":"link","label":"Recycling","href":"/flash-list/docs/recycling","docId":"fundamentals/recycling","unlisted":false}]},{"type":"category","label":"Guides","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"LayoutAnimation","href":"/flash-list/docs/guides/layout-animation","docId":"guides/layout-animation","unlisted":false},{"type":"link","label":"Manual linking","href":"/flash-list/docs/guides/manual-linking","docId":"guides/manual-linking","unlisted":false},{"type":"link","label":"Masonry Layout","href":"/flash-list/docs/guides/masonry","docId":"guides/masonry","unlisted":false},{"type":"link","label":"React Native Reanimated","href":"/flash-list/docs/guides/reanimated","docId":"guides/reanimated","unlisted":false},{"type":"link","label":"SectionList","href":"/flash-list/docs/guides/section-list","docId":"guides/section-list","unlisted":false},{"type":"link","label":"Testing with Jest","href":"/flash-list/docs/testing","docId":"guides/testing","unlisted":false}]},{"type":"link","label":"Known issues","href":"/flash-list/docs/known-issues","docId":"known-issues","unlisted":false},{"type":"link","label":"What\'s new in v2","href":"/flash-list/docs/v2-changes","docId":"v2-changes","unlisted":false}]},"docs":{"fundamentals/performance":{"id":"fundamentals/performance","title":"Performance","description":"Profiling","sidebar":"autoSidebar"},"fundamentals/recycling":{"id":"fundamentals/recycling","title":"Recycling","description":"One important thing to understand is how FlashList works under the hood. When an item gets out of the viewport, instead of being destroyed, the component is re-rendered with a different item prop. For example, if you make use of useState in a reused component, you may see state values that were set for that component when it was associated with a different item in the list, and would then need to reset any previously set state when a new item is rendered. FlashList now comes with useRecyclingState hook that can reet the state automatically without an additional render.","sidebar":"autoSidebar"},"fundamentals/usage":{"id":"fundamentals/usage","title":"Usage","description":"If you are familiar with FlatList, you already know how to use FlashList. You can try out FlashList by changing the component name.","sidebar":"autoSidebar"},"guides/layout-animation":{"id":"guides/layout-animation","title":"LayoutAnimation","description":"LayoutAnimation is a popular way how to animate views in React Native.","sidebar":"autoSidebar"},"guides/manual-linking":{"id":"guides/manual-linking","title":"Manual linking","description":"iOS","sidebar":"autoSidebar"},"guides/masonry":{"id":"guides/masonry","title":"Masonry Layout","description":"Masonry Layout allows you to create a grid of items with different heights. It is a great way to display a collection of images with different sizes.","sidebar":"autoSidebar"},"guides/reanimated":{"id":"guides/reanimated","title":"React Native Reanimated","description":"React Native Reanimated is an alternative animation library to the LayoutAnimation API provided by React Native.","sidebar":"autoSidebar"},"guides/section-list":{"id":"guides/section-list","title":"SectionList","description":"React Native has a convenience component on top of FlatList, called SectionList. This component has some additional props:","sidebar":"autoSidebar"},"guides/testing":{"id":"guides/testing","title":"Testing with Jest","description":"Since FlashList does not immediately render but waits for the size of the underlying ScrollView (unless you specify estimatedListSize), we need to mock triggering onLayout event.","sidebar":"autoSidebar"},"introduction":{"id":"introduction","title":"Introduction \ud83d\udcda","description":"Fast & performant React Native list. No more blank cells.","sidebar":"autoSidebar"},"known-issues":{"id":"known-issues","title":"Known issues","description":"FlashList and FlatList have very different internal. While the API is almost the same, the behaviour might be different in some cases due to a bug, limitation or missing implementation. In any case, if the issue is already listed here don\'t create a new one.","sidebar":"autoSidebar"},"v2-changes":{"id":"v2-changes","title":"What\'s new in v2","description":"New props","sidebar":"autoSidebar"}}}}')}}]);