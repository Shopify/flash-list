"use strict";(self.webpackChunkflash_list=self.webpackChunkflash_list||[]).push([[706],{8453:(e,s,t)=>{t.d(s,{R:()=>o,x:()=>l});var i=t(6540);const n={},a=i.createContext(n);function o(e){const s=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),i.createElement(a.Provider,{value:s},e.children)}},8623:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>r,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"known-issues","title":"Known issues","description":"FlashList and FlatList have very different internals. While the API is almost the same, the behaviour might be different in some cases due to a bug, limitation or missing implementation. In any case, if the issue is already listed here don\'t create a new one.","source":"@site/docs/known-issues.md","sourceDirName":".","slug":"/known-issues","permalink":"/flash-list/docs/known-issues","draft":false,"unlisted":false,"editUrl":"https://github.com/Shopify/flash-list/blob/main/documentation/docs/known-issues.md","tags":[],"version":"current","lastUpdatedBy":"Talha Naqvi","lastUpdatedAt":1748301724000,"sidebarPosition":3,"frontMatter":{"id":"known-issues","title":"Known issues","slug":"/known-issues","sidebar_position":3},"sidebar":"autoSidebar","previous":{"title":"Testing with Jest","permalink":"/flash-list/docs/testing"},"next":{"title":"What\'s new in v2","permalink":"/flash-list/docs/v2-changes"}}');var n=t(4848),a=t(8453);const o={id:"known-issues",title:"Known issues",slug:"/known-issues",sidebar_position:3},l="Known Issues",r={},h=[{value:"1) Horizontal lists + RTL Layout",id:"1-horizontal-lists--rtl-layout",level:3},{value:"2) Horizontal Lists with headers",id:"2-horizontal-lists-with-headers",level:3}];function d(e){const s={code:"code",h1:"h1",h3:"h3",header:"header",p:"p",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"known-issues",children:"Known Issues"})}),"\n",(0,n.jsx)(s.p,{children:"FlashList and FlatList have very different internals. While the API is almost the same, the behaviour might be different in some cases due to a bug, limitation or missing implementation. In any case, if the issue is already listed here don't create a new one."}),"\n",(0,n.jsx)(s.h3,{id:"1-horizontal-lists--rtl-layout",children:"1) Horizontal lists + RTL Layout"}),"\n",(0,n.jsxs)(s.p,{children:["We have a limitation where we're not able to read the padding applied on the list using ",(0,n.jsx)(s.code,{children:"contentContainerStyle"}),". Small values shouldn't cause an issue; however, if you require precise ",(0,n.jsx)(s.code,{children:"scrollTo"})," or ",(0,n.jsx)(s.code,{children:"initialScrollIndex"}),", then apply padding or margin to the header instead. Please note that this applies only to RTL language layouts."]}),"\n",(0,n.jsx)(s.h3,{id:"2-horizontal-lists-with-headers",children:"2) Horizontal Lists with headers"}),"\n",(0,n.jsxs)(s.p,{children:["If the horizontal list has a fixed size or header, we assume that the height of the list is fixed. If your use case requires the list to match the size of the items or resize based on tallest child, just skip using the header. You can just render the header as the first item in the list and give it a separate type using ",(0,n.jsx)(s.code,{children:"getItemType"}),"."]})]})}function u(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);