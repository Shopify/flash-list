"use strict";(self.webpackChunkflash_list=self.webpackChunkflash_list||[]).push([[854],{4971:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"fundamentals/layout-commit-observer","title":"Layout Commit Observer","description":"The LayoutCommitObserver is a utility component that helps you track when all FlashList components in your component tree have completed their layout. This is particularly useful for coordinating complex UI behaviors that depend on list rendering completion. Doing your own setState in this callback will block paint till your state change is ready to be committed.","source":"@site/docs/fundamentals/layout-commit-observer.md","sourceDirName":"fundamentals","slug":"/fundamentals/layout-commit-observer","permalink":"/flash-list/docs/fundamentals/layout-commit-observer","draft":false,"unlisted":false,"editUrl":"https://github.com/Shopify/flash-list/blob/main/documentation/docs/fundamentals/layout-commit-observer.md","tags":[],"version":"current","lastUpdatedBy":"Bartosz Kaszubowski","lastUpdatedAt":1757634122000,"frontMatter":{"id":"layout-commit-observer","title":"Layout Commit Observer"},"sidebar":"autoSidebar","previous":{"title":"Usage","permalink":"/flash-list/docs/usage"},"next":{"title":"Performance","permalink":"/flash-list/docs/fundamentals/performance"}}');var s=o(4848),a=o(8453);const i={id:"layout-commit-observer",title:"Layout Commit Observer"},r="Layout Commit Observer",l={},c=[{value:"Overview",id:"overview",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"When not to use",id:"when-not-to-use",level:2},{value:"Basic Usage",id:"basic-usage",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"layout-commit-observer",children:"Layout Commit Observer"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"LayoutCommitObserver"})," is a utility component that helps you track when all FlashList components in your component tree have completed their layout. This is particularly useful for coordinating complex UI behaviors that depend on list rendering completion. Doing your own ",(0,s.jsx)(t.code,{children:"setState"})," in this callback will block paint till your state change is ready to be committed."]}),"\n",(0,s.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(t.p,{children:"When working with multiple FlashList components or when you need to perform actions after a FlashList has finished its render, the LayoutCommitObserver provides a clean way to observe and react to these layout events. Please note that the callback is fired after every layout operation and not just the first one."}),"\n",(0,s.jsx)(t.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Measure size of views after all internal lists have rendered"}),"\n",(0,s.jsxs)(t.li,{children:["Don't have access to FlashList for example, your component just accepts ",(0,s.jsx)(t.code,{children:"children"})," prop."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"when-not-to-use",children:"When not to use"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["If you don't need to block paint then using the ",(0,s.jsx)(t.code,{children:"onLoad"})," callback is a better approach."]}),"\n",(0,s.jsxs)(t.li,{children:["If you only have one FlashList and have access to it. ",(0,s.jsx)(t.code,{children:"onCommitLayoutEffect"})," is a prop on FlashList too."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsx)(t.p,{children:"Wrap your component tree containing FlashLists with LayoutCommitObserver:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'import { LayoutCommitObserver } from "@shopify/flash-list";\n\nfunction MyScreen() {\n  const handleLayoutComplete = () => {\n    console.log("All FlashLists have completed their initial layout!");\n    // Perform any post-layout actions here\n  };\n\n  return (\n    <LayoutCommitObserver onCommitLayoutEffect={handleLayoutComplete}>\n      <View>\n        <FlashList data={data1} renderItem={renderItem1} />\n        <FlashList data={data2} renderItem={renderItem2} />\n      </View>\n    </LayoutCommitObserver>\n  );\n}\n'})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>i,x:()=>r});var n=o(6540);const s={},a=n.createContext(s);function i(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);