"use strict";(self.webpackChunkflash_list=self.webpackChunkflash_list||[]).push([[559],{8034:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"fundamentals/performance","title":"Performance","description":"Profiling","source":"@site/docs/fundamentals/performant-components.md","sourceDirName":"fundamentals","slug":"/fundamentals/performance","permalink":"/flash-list/docs/fundamentals/performance","draft":false,"unlisted":false,"editUrl":"https://github.com/Shopify/flash-list/blob/main/documentation/docs/fundamentals/performant-components.md","tags":[],"version":"current","lastUpdatedBy":"Bartosz Kaszubowski","lastUpdatedAt":1757634122000,"frontMatter":{"id":"performance","title":"Performance"},"sidebar":"autoSidebar","previous":{"title":"Layout Commit Observer","permalink":"/flash-list/docs/fundamentals/layout-commit-observer"},"next":{"title":"Recycling","permalink":"/flash-list/docs/recycling"}}');var i=t(4848),r=t(8453);const o={id:"performance",title:"Performance"},a=void 0,l={},c=[{value:"Profiling",id:"profiling",level:2},{value:"Recycling",id:"recycling",level:2},{value:"Optimizations",id:"optimizations",level:2},{value:"Remove <code>key</code> prop",id:"remove-key-prop",level:3},{value:"Why are keys harmful to FlashList?",id:"why-are-keys-harmful-to-flashlist",level:4},{value:"Difficult calculations",id:"difficult-calculations",level:3},{value:"<code>getItemType</code>",id:"getitemtype",level:3},{value:"Leaf components",id:"leaf-components",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"profiling",children:"Profiling"}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["Before assessing your list's performance, make sure you are in release mode. On Android, you can disable JS dev mode inside the developer menu, whereas you need to run the release configuration on iOS.\nFlashList can appear to be slower than FlatList in dev mode. The primary reason is a much smaller and fixed ",(0,i.jsx)(n.a,{href:"https://reactnative.dev/docs/virtualizedlist#windowsize",children:"window size"})," equivalent. Click ",(0,i.jsx)(n.a,{href:"https://reactnative.dev/docs/performance#running-in-development-mode-devtrue",children:"here"})," to know more about why you shouldn't profile with dev mode on."]})}),"\n",(0,i.jsx)(n.p,{children:"Memoizing props passed to FlashList is more important in v2. v1 was more selective about updating items, but this was often perceived as a bug by developers. We will not follow that approach and will instead allow developers to ensure that props are memoized. We will stop re-renders of children wherever it is obvious."}),"\n",(0,i.jsx)(n.h1,{id:"writing-performant-components",children:"Writing Performant Components"}),"\n",(0,i.jsxs)(n.p,{children:["While ",(0,i.jsx)(n.code,{children:"FlashList"})," does its best to achieve high performance, it will still perform poorly if your item components are slow to render. In this post, let's dive deeper into how you can remedy this."]}),"\n",(0,i.jsx)(n.h2,{id:"recycling",children:"Recycling"}),"\n",(0,i.jsxs)(n.p,{children:["One important thing to understand is how ",(0,i.jsx)(n.code,{children:"FlashList"})," works under the hood. When an item gets out of the viewport, instead of being destroyed, the component is re-rendered with a different ",(0,i.jsx)(n.code,{children:"item"})," prop. When optimizing your item component, try to ensure as few things as possible have to be re-rendered and recomputed when recycling."]}),"\n",(0,i.jsx)(n.h2,{id:"optimizations",children:"Optimizations"}),"\n",(0,i.jsxs)(n.p,{children:["There's lots of optimizations that are applicable for ",(0,i.jsx)(n.em,{children:"any"})," React Native component and which might help render times of your item components as well. Usage of ",(0,i.jsx)(n.code,{children:"useCallback"}),", ",(0,i.jsx)(n.code,{children:"useMemo"}),", and ",(0,i.jsx)(n.code,{children:"useRef"})," is advised - but don't use these blindly, always measure the performance before and after making your changes."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["Always profile performance in the release mode. ",(0,i.jsx)(n.code,{children:"FlashList"}),"'s performance between JS dev and release mode differs greatly."]})}),"\n",(0,i.jsxs)(n.h3,{id:"remove-key-prop",children:["Remove ",(0,i.jsx)(n.code,{children:"key"})," prop"]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["Using ",(0,i.jsx)(n.code,{children:"key"})," prop inside your item and item's nested components will highly degrade performance."]})}),"\n",(0,i.jsxs)(n.p,{children:["Make sure your ",(0,i.jsxs)(n.strong,{children:["item components and their nested components don't have a ",(0,i.jsx)(n.code,{children:"key"})," prop"]}),". Using this prop will lead to ",(0,i.jsx)(n.code,{children:"FlashList"})," not being able to recycle views, losing all the benefits of using it over ",(0,i.jsx)(n.code,{children:"FlatList"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"why-are-keys-harmful-to-flashlist",children:"Why are keys harmful to FlashList?"}),"\n",(0,i.jsxs)(n.p,{children:["FlashList's core performance advantage comes from ",(0,i.jsx)(n.strong,{children:"recycling"})," components instead of creating and destroying them however, when you add a ",(0,i.jsx)(n.code,{children:"key"})," prop that changes between different data items, React treats the component as entirely different and forces a complete re-creation of the component tree."]}),"\n",(0,i.jsx)(n.p,{children:"For example, if we had a following item component:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const MyNestedComponent = ({ item }) => {\n  return <Text key={item.id}>I am nested!</Text>;\n};\n\nconst MyItem = ({ item }) => {\n  return (\n    <View key={item.id}>\n      <MyNestedComponent item={item} />\n      <Text>{item.title}</Text>\n    </View>\n  );\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Then the ",(0,i.jsx)(n.code,{children:"key"})," prop should be removed from both ",(0,i.jsx)(n.code,{children:"MyItem"})," and ",(0,i.jsx)(n.code,{children:"MyNestedComponent"}),". It isn't needed and react can alredy take care of updating the components."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const MyNestedComponent = ({ item }) => {\n  return <Text>I am nested!</Text>;\n};\n\nconst MyItem = ({ item }) => {\n  return (\n    <View>\n      <MyNestedComponent item={item} />\n      <Text>{item.title}</Text>\n    </View>\n  );\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["There might be cases where React forces you to use ",(0,i.jsx)(n.code,{children:"key"})," prop, such as when using ",(0,i.jsx)(n.code,{children:"map"}),". In such circumstances, ",(0,i.jsxs)(n.strong,{children:["use ",(0,i.jsx)(n.code,{children:"useMappingHelper"})]})," to ensure optimal performance:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'import { useMappingHelper } from "@shopify/flash-list";\n\nconst MyItem = ({ item }) => {\n  const { getMappingKey } = useMappingHelper();\n\n  return (\n    <>\n      {item.users.map((user, index) => (\n        <Text key={getMappingKey(user.id, index)}>{user.name}</Text>\n      ))}\n    </>\n  );\n};\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"useMappingHelper"})," hook intelligently provides the right key strategy:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"When inside FlashList"}),": Uses stable keys that don't change during recycling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"When outside FlashList"}),": Uses the provided item key for proper React reconciliation"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This approach ensures that:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Components can be recycled properly within FlashList"}),"\n",(0,i.jsx)(n.li,{children:"React's reconciliation works correctly"}),"\n",(0,i.jsx)(n.li,{children:"Performance remains optimal"}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"useMappingHelper"})," should be used whenever you need to map over arrays inside FlashList item components. It automatically handles the complexity of providing recycling-friendly keys."]})}),"\n",(0,i.jsx)(n.h3,{id:"difficult-calculations",children:"Difficult calculations"}),"\n",(0,i.jsx)(n.p,{children:"If you do any calculations that might take a lot of resources, consider memoizing it, making it faster, or removing it altogether. The render method of items should be as efficient as possible:"}),"\n",(0,i.jsx)(n.h3,{id:"getitemtype",children:(0,i.jsx)(n.code,{children:"getItemType"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["If you have different types of cell components and these are vastly different, consider leveraging the ",(0,i.jsxs)(n.a,{href:"/usage#getitemtype",children:[(0,i.jsx)(n.code,{children:"getItemType"})," prop"]})]}),". For example, if we were building a messages list, we could write it like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// A message can be either a text or an image\nenum MessageType {\n  Text,\n  Image,\n}\n\ninterface TextMessage {\n  text: string;\n  type: MessageType.Text;\n}\n\ninterface ImageMessage {\n  image: ImageSourcePropType;\n  type: MessageType.Image;\n}\n\ntype Message = ImageMessage | TextMessage;\n\nconst MessageItem = ({ item }: { item: Message }) => {\n  switch (item.type) {\n    case MessageType.Text:\n      return <Text>{item.text}</Text>;\n    case MessageType.Image:\n      return <Image source={item.image} />;\n  }\n};\n\n// Rendering the actual messages list\nconst MessageList = () => {\n  return <FlashList renderItem={MessageItem} />;\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["However, this implementation has one performance drawback. When the list recycles items and the ",(0,i.jsx)(n.code,{children:"MessageType"})," changes from ",(0,i.jsx)(n.code,{children:"Text"})," to ",(0,i.jsx)(n.code,{children:"Image"})," or vice versa, React won't be able to optimize the re-render since the whole render tree of the item component changes. We can fix this by changing the ",(0,i.jsx)(n.code,{children:"MessageList"})," to this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const MessageList = () => {\n  return (\n    <FlashList\n      renderItem={MessageItem}\n      estimatedItemSize={200}\n      getItemType={(item) => {\n        return item.type;\n      }}\n    />\n  );\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"FlashList"})," will now use separate recycling pools based on ",(0,i.jsx)(n.code,{children:"item.type"}),". That means we will never recycle items of different types, making the re-render faster."]}),"\n",(0,i.jsx)(n.h3,{id:"leaf-components",children:"Leaf components"}),"\n",(0,i.jsx)(n.p,{children:"Let's consider the following example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const MyHeavyComponent = () => {\n  return ...;\n};\n\nconst MyItem = ({ item }) => {\n  return (\n    <>\n      <MyHeavyComponent />\n      <Text>{item.title}</Text>\n    </>\n  );\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Since ",(0,i.jsx)(n.code,{children:"MyHeavyComponent"})," does not directly depend on the ",(0,i.jsx)(n.code,{children:"item"})," prop, ",(0,i.jsx)(n.code,{children:"memo"})," can be used to skip re-rending ",(0,i.jsx)(n.code,{children:"MyHeavyComponent"})," when the item is recycled and thus re-rendered:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const MyHeavyComponent = () => {\n  return ...;\n};\n\nconst MemoizedMyHeavyComponent = memo(MyHeavyComponent);\n\nconst MyItem = ({ item }: { item: any }) => {\n  return (\n    <>\n      <MemoizedMyHeavyComponent />\n      <Text>{item.title}</Text>\n    </>\n  );\n};\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);