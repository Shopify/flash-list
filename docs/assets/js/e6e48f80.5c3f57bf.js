"use strict";(self.webpackChunkflash_list=self.webpackChunkflash_list||[]).push([[615],{7516:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"fundamentals/usage","title":"Usage","description":"If you are familiar with FlatList, you already know how to use FlashList. You can try out FlashList by changing the component name.","source":"@site/docs/fundamentals/usage.md","sourceDirName":"fundamentals","slug":"/usage","permalink":"/flash-list/docs/usage","draft":false,"unlisted":false,"editUrl":"https://github.com/Shopify/flash-list/blob/main/documentation/docs/fundamentals/usage.md","tags":[],"version":"current","lastUpdatedBy":"Bartosz Kaszubowski","lastUpdatedAt":1757634122000,"sidebarPosition":0,"frontMatter":{"id":"usage","title":"Usage","slug":"/usage","sidebar_position":0},"sidebar":"autoSidebar","previous":{"title":"Introduction \ud83d\udcda","permalink":"/flash-list/docs/"},"next":{"title":"Layout Commit Observer","permalink":"/flash-list/docs/fundamentals/layout-commit-observer"}}');var s=i(4848),l=i(8453);const o={id:"usage",title:"Usage",slug:"/usage",sidebar_position:0},r=void 0,d={},a=[{value:"Important things to know",id:"migration-steps",level:2},{value:"<strong><code>renderItem</code></strong>",id:"renderitem",level:3},{value:"<strong><code>data</code></strong>",id:"data",level:3},{value:"<code>CellRendererComponent</code>",id:"cellrenderercomponent",level:3},{value:"<code>ItemSeparatorComponent</code>",id:"itemseparatorcomponent",level:3},{value:"<code>ListEmptyComponent</code>",id:"listemptycomponent",level:3},{value:"<code>ListFooterComponent</code>",id:"listfootercomponent",level:3},{value:"<code>ListFooterComponentStyle</code>",id:"listfootercomponentstyle",level:3},{value:"<code>ListHeaderComponent</code>",id:"listheadercomponent",level:3},{value:"<code>ListHeaderComponentStyle</code>",id:"listheadercomponentstyle",level:3},{value:"<code>contentContainerStyle</code>",id:"contentcontainerstyle",level:3},{value:"<code>drawDistance</code>",id:"drawdistance",level:3},{value:"<code>extraData</code>",id:"extradata",level:3},{value:"<code>horizontal</code>",id:"horizontal",level:3},{value:"<code>initialScrollIndex</code>",id:"initialscrollindex",level:3},{value:"<code>keyExtractor</code>",id:"keyextractor",level:3},{value:"<code>maintainVisibleContentPosition</code>",id:"maintainvisiblecontentposition",level:3},{value:"<code>masonry</code>",id:"masonry",level:3},{value:"<code>maxItemsInRecyclePool</code>",id:"maxitemsinrecyclepool",level:3},{value:"<code>numColumns</code>",id:"numcolumns",level:3},{value:"<code>onBlankArea</code>",id:"onblankarea",level:3},{value:"<code>onCommitLayoutEffect</code>",id:"oncommitlayouteffect",level:3},{value:"<code>onEndReached</code>",id:"onendreached",level:3},{value:"<code>onEndReachedThreshold</code>",id:"onendreachedthreshold",level:3},{value:"<code>onLoad</code>",id:"onload",level:3},{value:"<code>onRefresh</code>",id:"onrefresh",level:3},{value:"<code>getItemType</code>",id:"getitemtype",level:3},{value:"<code>onStartReached</code>",id:"onstartreached",level:3},{value:"<code>onStartReachedThreshold</code>",id:"onstartreachedthreshold",level:3},{value:"<code>onViewableItemsChanged</code>",id:"onviewableitemschanged",level:3},{value:"<code>optimizeItemArrangement</code>",id:"optimizeitemarrangement",level:3},{value:"<code>overrideItemLayout</code>",id:"overrideitemlayout",level:3},{value:"<code>overrideProps</code>",id:"overrideprops",level:3},{value:"<code>progressViewOffset</code>",id:"progressviewoffset",level:3},{value:"<code>refreshControl</code>",id:"refreshcontrol",level:3},{value:"<code>refreshing</code>",id:"refreshing",level:3},{value:"<code>renderScrollComponent</code>",id:"renderscrollcomponent",level:3},{value:"<code>style</code>",id:"style",level:3},{value:"<code>viewabilityConfig</code>",id:"viewabilityconfig",level:3},{value:"minimumViewTime",id:"minimumviewtime",level:4},{value:"viewAreaCoveragePercentThreshold",id:"viewareacoveragepercentthreshold",level:4},{value:"itemVisiblePercentThreshold",id:"itemvisiblepercentthreshold",level:4},{value:"waitForInteraction",id:"waitforinteraction",level:4},{value:"<code>viewabilityConfigCallbackPairs</code>",id:"viewabilityconfigcallbackpairs",level:3},{value:"useLayoutState",id:"uselayoutstate",level:3},{value:"useRecyclingState",id:"userecyclingstate",level:3},{value:"useMappingHelper",id:"usemappinghelper",level:3},{value:"useFlashListContext",id:"useflashlistcontext",level:3},{value:"<code>prepareForLayoutAnimationRender()</code>",id:"prepareforlayoutanimationrender",level:3},{value:"<code>recordInteraction()</code>",id:"recordinteraction",level:3},{value:"<code>recomputeViewableItems()</code>",id:"recomputeviewableitems",level:3},{value:"<code>scrollToEnd()</code>",id:"scrolltoend",level:3},{value:"<code>scrollToIndex()</code>",id:"scrolltoindex",level:3},{value:"<code>scrollToItem()</code>",id:"scrolltoitem",level:3},{value:"<code>scrollToOffset()</code>",id:"scrolltooffset",level:3},{value:"<code>getVisibleIndices()</code>",id:"getvisibleindices",level:3},{value:"<code>getLayout()</code>",id:"getlayout",level:3},{value:"<code>flashScrollIndicators()</code>",id:"flashscrollindicators",level:3},{value:"<code>getNativeScrollRef()</code>",id:"getnativescrollref",level:3},{value:"<code>getScrollResponder()</code>",id:"getscrollresponder",level:3},{value:"<code>getScrollableNode()</code>",id:"getscrollablenode",level:3},{value:"<code>scrollToTop()</code>",id:"scrolltotop",level:3},{value:"<code>getFirstItemOffset()</code>",id:"getfirstitemoffset",level:3},{value:"<code>getWindowSize()</code>",id:"getwindowsize",level:3},{value:"<code>getFirstVisibleIndex()</code>",id:"getfirstvisibleindex",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["If you are familiar with ",(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/flatlist",children:"FlatList"}),", you already know how to use ",(0,s.jsx)(n.code,{children:"FlashList"}),". You can try out ",(0,s.jsx)(n.code,{children:"FlashList"})," by changing the component name."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import React from "react";\nimport { View, Text, StatusBar } from "react-native";\nimport { FlashList } from "@shopify/flash-list";\n\nconst DATA = [\n  {\n    title: "First Item",\n  },\n  {\n    title: "Second Item",\n  },\n];\n\nconst MyList = () => {\n  return (\n    <FlashList\n      data={DATA}\n      renderItem={({ item }) => <Text>{item.title}</Text>}\n    />\n  );\n};\n'})}),"\n",(0,s.jsx)(n.h2,{id:"migration-steps",children:"Important things to know"}),"\n",(0,s.jsxs)(n.p,{children:["To avoid common pitfalls, you can also follow these steps for migrating from ",(0,s.jsx)(n.code,{children:"FlatList"}),", based on our own experience."]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Simply change from ",(0,s.jsx)(n.code,{children:"FlatList"})," to ",(0,s.jsx)(n.code,{children:"FlashList"})," and render the list."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Important"}),": Scan your ",(0,s.jsx)(n.a,{href:"https://shopify.github.io/flash-list/docs/usage/#renderitem",children:(0,s.jsx)(n.code,{children:"renderItem"})})," hierarchy for explicit ",(0,s.jsx)(n.code,{children:"key"})," prop definitions and remove them. If you\u2019re doing a ",(0,s.jsx)(n.code,{children:".map()"})," use our hook called ",(0,s.jsx)(n.a,{href:"https://shopify.github.io/flash-list/docs/usage/#usemappinghelper",children:(0,s.jsx)(n.code,{children:"useMappingHelper"})}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Check your ",(0,s.jsx)(n.a,{href:"https://shopify.github.io/flash-list/docs/usage/#renderitem",children:(0,s.jsx)(n.code,{children:"renderItem"})})," hierarchy for components that make use of ",(0,s.jsx)(n.code,{children:"useState"})," and verify whether that state would need to be reset if a different item is passed to that component (see ",(0,s.jsx)(n.a,{href:"https://shopify.github.io/flash-list/docs/recycling",children:"Recycling"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["If your list has heterogenous views, pass their types to ",(0,s.jsx)(n.code,{children:"FlashList"})," using ",(0,s.jsx)(n.a,{href:"https://shopify.github.io/flash-list/docs/usage/#getitemtype",children:(0,s.jsx)(n.code,{children:"getItemType"})})," prop to improve performance."]}),"\n",(0,s.jsxs)(n.li,{children:["Do not test performance with JS dev mode on. Make sure you\u2019re in release mode. ",(0,s.jsx)(n.code,{children:"FlashList"})," can appear slower while in dev mode due to a small render buffer."]}),"\n",(0,s.jsx)(n.li,{children:"Memoizing props passed to FlashList is more important in v2. v1 was more selective about updating items, but this was often perceived as a bug by developers. We will not follow that approach and will instead allow developers to ensure that props are memoized. We will stop re-renders of children wherever it is obvious."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"keyExtractor"})," is important to prevent glitches due to item layout changes when going upwards. We highly recommend having a valid ",(0,s.jsx)(n.code,{children:"keyExtractor"})," with v2."]}),"\n",(0,s.jsxs)(n.li,{children:["Read about new hooks that simplify recycling and reacting to layout changes: ",(0,s.jsx)(n.a,{href:"https://shopify.github.io/flash-list/docs/usage/#usemappinghelper",children:(0,s.jsx)(n.code,{children:"useLayoutState"})}),", ",(0,s.jsx)(n.a,{href:"https://shopify.github.io/flash-list/docs/usage/#usemappinghelper",children:(0,s.jsx)(n.code,{children:"useRecyclingState"})})]}),"\n",(0,s.jsx)(n.li,{children:"If you're nesting horizontal FlashLists in vertical lists, we highly recommend the vertical list to be FlashList too. We have optimizations to wait for child layout to complete which can improve load times."}),"\n"]}),"\n",(0,s.jsx)(n.h1,{id:"props",children:"Props"}),"\n",(0,s.jsx)(n.h3,{id:"renderitem",children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"renderItem"})})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"Required"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"renderItem: ({ item, index, target, extraData }) => void;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Takes an item from ",(0,s.jsx)(n.code,{children:"data"})," and renders it into the list. Typical usage:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"renderItem = ({item}) => (\n  <Text>{item.title}</Text>\n);\n...\n<FlashList data={[{title: 'Title Text', key: 'item1'}]} renderItem={renderItem} />\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Provides additional metadata like ",(0,s.jsx)(n.code,{children:"index"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"item"})," (",(0,s.jsx)(n.code,{children:"Object"}),"): The item from ",(0,s.jsx)(n.code,{children:"data"})," being rendered."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"index"})," (",(0,s.jsx)(n.code,{children:"number"}),"): The index corresponding to this item in the ",(0,s.jsx)(n.code,{children:"data"})," array."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"target"})," (",(0,s.jsx)(n.code,{children:"string"}),"): FlashList may render your items for multiple reasons.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Cell"})," - This is for your list item."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Measurement"})," - Might be invoked for size measurement and won't be visible. You can ignore this in analytics."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"StickyHeader"})," - This is for your sticky header. Use this to change your item's appearance while it's being used as a sticky header."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"extraData"})," (",(0,s.jsx)(n.code,{children:"Object"}),") - This is the same ",(0,s.jsx)(n.code,{children:"extraData"})," prop that was passed to ",(0,s.jsx)(n.code,{children:"FlashList"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"data",children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"data"})})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"Required"})}),"\n",(0,s.jsx)(n.p,{children:"For simplicity, data is a plain array of items of a given type."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"data: ItemT[];\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cellrenderercomponent",children:(0,s.jsx)(n.code,{children:"CellRendererComponent"})}),"\n",(0,s.jsxs)(n.p,{children:["Each cell is rendered using this element. Can be a React Component Class, or a render function. The root component should always be a ",(0,s.jsx)(n.code,{children:"CellContainer"})," which is also the default component used. Ensure that the original ",(0,s.jsx)(n.code,{children:"props"})," are passed to the returned ",(0,s.jsx)(n.code,{children:"CellContainer"}),". The ",(0,s.jsx)(n.code,{children:"props"})," contain the following properties:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onLayout"}),": Method for updating data about the real ",(0,s.jsx)(n.code,{children:"CellContainer"})," layout"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"index"}),": Index of the cell in the list, you can use this to query data if needed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"style"}),": Style of ",(0,s.jsx)(n.code,{children:"CellContainer"}),", including:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"flexDirection"}),": Depends on whether your list is horizontal or vertical"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"position"}),": Value of this will be ",(0,s.jsx)(n.code,{children:"absolute"})," as that's how ",(0,s.jsx)(n.code,{children:"FlashList"})," positions elements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"left"}),": Determines position of the element on x axis"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"top"}),": Determines position of the element on y axis"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"width"}),": Determines width of the element (present when list is vertical)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"height"}),": Determines height of the element (present when list is horizontal)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["When using with ",(0,s.jsx)(n.code,{children:"react-native-reanimated"}),", you can wrap ",(0,s.jsx)(n.code,{children:"CellContainer"})," in ",(0,s.jsx)(n.code,{children:"Animated.createAnimatedComponent"})," (this is similar to using ",(0,s.jsx)(n.code,{children:"Animated.View"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const AnimatedCellContainer = Animated.createAnimatedComponent(CellContainer);\nreturn (\n  <FlashList\n    CellRendererComponent={(props) => {\n      return (\n          <AnimatedCellContainer {...props} style={...}>\n      );\n    }}\n  />\n);\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"CellRendererComponent?: React.ComponentType<any> | undefined;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"itemseparatorcomponent",children:(0,s.jsx)(n.code,{children:"ItemSeparatorComponent"})}),"\n",(0,s.jsxs)(n.p,{children:["Rendered in between each item, but not at the top or bottom. By default, ",(0,s.jsx)(n.code,{children:"leadingItem"})," and ",(0,s.jsx)(n.code,{children:"trailingItem"})," (if available) props are provided."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"ItemSeparatorComponent?: React.ComponentType<any>;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"listemptycomponent",children:(0,s.jsx)(n.code,{children:"ListEmptyComponent"})}),"\n",(0,s.jsxs)(n.p,{children:["Rendered when the list is empty. Can be a React Component (e.g. ",(0,s.jsx)(n.code,{children:"SomeComponent"}),"), or a React element (e.g. ",(0,s.jsx)(n.code,{children:"<SomeComponent />"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"ListEmptyComponent?: React.ComponentType<any> | React.ReactElement<any, string | React.JSXElementConstructor<any>>;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"listfootercomponent",children:(0,s.jsx)(n.code,{children:"ListFooterComponent"})}),"\n",(0,s.jsxs)(n.p,{children:["Rendered at the bottom of all the items. Can be a React Component (e.g. ",(0,s.jsx)(n.code,{children:"SomeComponent"}),"), or a React element (e.g. ",(0,s.jsx)(n.code,{children:"<SomeComponent />"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"ListFooterComponent?: React.ComponentType<any> | React.ReactElement<any, string | React.JSXElementConstructor<any>>;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"listfootercomponentstyle",children:(0,s.jsx)(n.code,{children:"ListFooterComponentStyle"})}),"\n",(0,s.jsxs)(n.p,{children:["Styling for internal View for ",(0,s.jsx)(n.code,{children:"ListFooterComponent"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"ListFooterComponentStyle?: StyleProp<ViewStyle>;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"listheadercomponent",children:(0,s.jsx)(n.code,{children:"ListHeaderComponent"})}),"\n",(0,s.jsxs)(n.p,{children:["Rendered at the top of all the items. Can be a React Component (e.g. ",(0,s.jsx)(n.code,{children:"SomeComponent"}),"), or a React element (e.g. ",(0,s.jsx)(n.code,{children:"<SomeComponent />"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"ListHeaderComponent?: React.ComponentType<any> | React.ReactElement<any, string | React.JSXElementConstructor<any>>;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"listheadercomponentstyle",children:(0,s.jsx)(n.code,{children:"ListHeaderComponentStyle"})}),"\n",(0,s.jsxs)(n.p,{children:["Styling for internal View for ",(0,s.jsx)(n.code,{children:"ListHeaderComponent"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"ListHeaderComponentStyle?: StyleProp<ViewStyle>;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"contentcontainerstyle",children:(0,s.jsx)(n.code,{children:"contentContainerStyle"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'contentContainerStyle?: ContentStyle;\n\nexport type ContentStyle = Pick<\n  ViewStyle,\n  | "backgroundColor"\n  | "paddingTop"\n  | "paddingLeft"\n  | "paddingRight"\n  | "paddingBottom"\n  | "padding"\n  | "paddingVertical"\n  | "paddingHorizontal"\n>;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.code,{children:"contentContainerStyle"})," to apply padding that will be applied to the whole content itself. For example, you can apply this padding, so that all of your items have leading and trailing space."]}),"\n",(0,s.jsx)(n.h3,{id:"drawdistance",children:(0,s.jsx)(n.code,{children:"drawDistance"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"drawDistance?: number;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Draw distance for advanced rendering (in ",(0,s.jsx)(n.code,{children:"dp"}),"/",(0,s.jsx)(n.code,{children:"px"}),")."]}),"\n",(0,s.jsx)(n.h3,{id:"extradata",children:(0,s.jsx)(n.code,{children:"extraData"})}),"\n",(0,s.jsxs)(n.p,{children:["A marker property for telling the list to re-render (since it implements ",(0,s.jsx)(n.code,{children:"PureComponent"}),"). If any of your ",(0,s.jsx)(n.code,{children:"renderItem"}),", Header, Footer, etc. functions depend on anything outside of the ",(0,s.jsx)(n.code,{children:"data"})," prop, stick it here and treat it immutably."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"extraData?: any;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"horizontal",children:(0,s.jsx)(n.code,{children:"horizontal"})}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"true"}),", renders items next to each other horizontally instead of stacked vertically. Default is ",(0,s.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"horizontal?: boolean;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"initialscrollindex",children:(0,s.jsx)(n.code,{children:"initialScrollIndex"})}),"\n",(0,s.jsxs)(n.p,{children:["Instead of starting at the top with the first item, start at ",(0,s.jsx)(n.code,{children:"initialScrollIndex"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"initialScrollIndex?: number;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"keyextractor",children:(0,s.jsx)(n.code,{children:"keyExtractor"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"keyExtractor?: (item: object, index: number) => string;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Used to extract a unique key for a given item at the specified index. Key is used for optimizing performance. Defining ",(0,s.jsx)(n.code,{children:"keyExtractor"})," is also necessary when doing ",(0,s.jsx)(n.a,{href:"/guides/layout-animation",children:"layout animations"})," to uniquely identify animated components."]}),"\n",(0,s.jsx)(n.h3,{id:"maintainvisiblecontentposition",children:(0,s.jsx)(n.code,{children:"maintainVisibleContentPosition"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"maintainVisibleContentPosition?: {\n  disabled?: boolean;\n  autoscrollToTopThreshold?: number;\n  autoscrollToBottomThreshold?: number;\n  startRenderingFromBottom?: boolean;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"Configuration for maintaining scroll position when content changes. This is enabled by default to reduce visible glitches."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"disabled"}),": Set to true to disable this feature. It's enabled by default."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"autoscrollToTopThreshold"}),": Automatically scroll to maintain position when content is added at the top."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"autoscrollToBottomThreshold"}),": Automatically scroll to maintain position when content is added at the bottom."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"animateAutoScrollToBottom"}),": Scroll with animation whenever ",(0,s.jsx)(n.code,{children:"autoScrollToBottom"})," is triggered. Default is ",(0,s.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"startRenderingFromBottom"}),": If true, initial render will start from the bottom, useful for chat interfaces."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<FlashList\n  data={chatMessages}\n  maintainVisibleContentPosition={{\n    autoscrollToBottomThreshold: 0.2,\n    startRenderingFromBottom: true,\n  }}\n  renderItem={({ item }) => <ChatMessage message={item} />}\n/>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"masonry",children:(0,s.jsx)(n.code,{children:"masonry"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"masonry?: boolean;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Enable masonry layout for grid-like interfaces with varying item heights. When used with ",(0,s.jsx)(n.code,{children:"numColumns > 1"}),", this creates a masonry-style layout."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<FlashList\n  data={data}\n  masonry\n  numColumns={3}\n  renderItem={({ item }) => <MasonryItem item={item} />}\n/>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"maxitemsinrecyclepool",children:(0,s.jsx)(n.code,{children:"maxItemsInRecyclePool"})}),"\n",(0,s.jsx)(n.p,{children:"Maximum number of items in the recycle pool. These are the items that are cached in the recycle pool when they are scrolled off the screen. Unless you have a huge number of item types, you shouldn't need to set this."}),"\n",(0,s.jsx)(n.p,{children:"Setting this to 0, will disable the recycle pool and items will unmount once they are scrolled off the screen.\nThere's no limit by default."}),"\n",(0,s.jsx)(n.h3,{id:"numcolumns",children:(0,s.jsx)(n.code,{children:"numColumns"})}),"\n",(0,s.jsxs)(n.p,{children:["Multiple columns can only be rendered with ",(0,s.jsx)(n.code,{children:"horizontal={false}"})," and will zig-zag like a ",(0,s.jsx)(n.code,{children:"flexWrap"})," layout. Items should all be the same height - masonry layouts are not supported."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"numColumns?: number;"})}),"\n",(0,s.jsx)(n.h3,{id:"onblankarea",children:(0,s.jsx)(n.code,{children:"onBlankArea"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"onBlankArea?: (blankAreaEvent: {\n    offsetStart: number;\n    offsetEnd: number;\n    blankArea: number;\n}) => void;\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"FlashList"})," computes blank space that is visible to the user during scrolling or the initial loading of the list."]}),"\n",(0,s.jsx)(n.p,{children:"Values reported:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"offsetStart"}),": visible blank space on top of the screen (while going up). If value is greater than 0, it's visible to user."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"offsetEnd"}),": visible blank space at the end of the screen (while going down). If value is greater than 0, it's visible to user."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"blankArea"}),": maximum of ",(0,s.jsx)(n.code,{children:"offsetStart"})," and ",(0,s.jsx)(n.code,{children:"offsetEnd"}),". You might see negative values indicating that items are rendered outside the list's visible area."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"This callback will be triggered even if the blanks are excepted - for example, when the list does not have enough items to fill the screen."})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["This event isn't synced with ",(0,s.jsx)(n.code,{children:"onScroll"})," event from the JS layer but works with native methods ",(0,s.jsx)(n.code,{children:"onDraw"})," (Android) and ",(0,s.jsx)(n.code,{children:"layoutSubviews"})," (iOS)."]})}),"\n",(0,s.jsx)(n.h3,{id:"oncommitlayouteffect",children:(0,s.jsx)(n.code,{children:"onCommitLayoutEffect"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"onCommitLayoutEffect?: () => void;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Called before layout is committed. Can be used to measure list and make changes before paint. Doing setState inside the callback can lead to infinite loops. Make sure FlashList's props are memoized."}),"\n",(0,s.jsx)(n.h3,{id:"onendreached",children:(0,s.jsx)(n.code,{children:"onEndReached"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"onEndReached?: () => void;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Called once when the scroll position gets within ",(0,s.jsx)(n.code,{children:"onEndReachedThreshold"})," of the rendered content."]}),"\n",(0,s.jsx)(n.h3,{id:"onendreachedthreshold",children:(0,s.jsx)(n.code,{children:"onEndReachedThreshold"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"onEndReachedThreshold?: number;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["How far from the end (in units of visible length of the list) the bottom edge of the list must be from the end of the content to trigger the ",(0,s.jsx)(n.code,{children:"onEndReached"})," callback. Thus a value of 0.5 will trigger ",(0,s.jsx)(n.code,{children:"onEndReached"})," when the end of the content is within half the visible length of the list."]}),"\n",(0,s.jsx)(n.h3,{id:"onload",children:(0,s.jsx)(n.code,{children:"onLoad"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"onLoad: (info: { elapsedTimeInMs: number }) => void;\n"})}),"\n",(0,s.jsx)(n.p,{children:"This event is raised once the list has drawn items on the screen. It also reports elapsedTimeInMs which is the time it took to draw the items. This is required because FlashList doesn't render items in the first cycle. Items are drawn after it measures itself at the end of first render. Please note that the event is not fired if ListEmptyComponent is rendered."}),"\n",(0,s.jsx)(n.h3,{id:"onrefresh",children:(0,s.jsx)(n.code,{children:"onRefresh"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"onRefresh?: () => void;\n"})}),"\n",(0,s.jsxs)(n.p,{children:['If provided, a standard RefreshControl will be added for "Pull to Refresh" functionality. Make sure to also set the ',(0,s.jsx)(n.code,{children:"refreshing"})," prop correctly."]}),"\n",(0,s.jsx)(n.h3,{id:"getitemtype",children:(0,s.jsx)(n.code,{children:"getItemType"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"getItemType?: (\n    item: T,\n    index: number,\n    extraData?: any\n) => string | number | undefined;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Allows developers to specify item types. This will improve recycling if you have different types of items in the list. Right type will be used for the right item.Default type is 0. If you don't want to change for an indexes just return undefined. You can see example of how to use this prop ",(0,s.jsx)(n.a,{href:"/flash-list/docs/fundamentals/performance#getitemtype",children:"here"}),"."]}),"\n",(0,s.jsx)(n.admonition,{title:"Performance",type:"warning",children:(0,s.jsx)(n.p,{children:"This method is called very frequently. Keep it fast."})}),"\n",(0,s.jsx)(n.h3,{id:"onstartreached",children:(0,s.jsx)(n.code,{children:"onStartReached"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"onStartReached?: () => void;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Called once when the scroll position gets within ",(0,s.jsx)(n.code,{children:"onStartReachedThreshold"})," of the start of the content. Useful for loading older content in infinite scroll scenarios like chat applications."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<FlashList\n  data={messageData}\n  onStartReached={() => loadOlderMessages()}\n  onStartReachedThreshold={0.1}\n  renderItem={({ item }) => <MessageItem message={item} />}\n/>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"onstartreachedthreshold",children:(0,s.jsx)(n.code,{children:"onStartReachedThreshold"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"onStartReachedThreshold?: number;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["How far from the start (in units of visible length of the list) the top edge of the list must be from the start of the content to trigger the ",(0,s.jsx)(n.code,{children:"onStartReached"})," callback. Value of 0.5 will trigger ",(0,s.jsx)(n.code,{children:"onStartReached"})," when the start of the content is within half the visible length of the list from the top."]}),"\n",(0,s.jsx)(n.h3,{id:"onviewableitemschanged",children:(0,s.jsx)(n.code,{children:"onViewableItemsChanged"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"interface ViewToken {\n  index: number;\n  isViewable: boolean;\n  item: string;\n  key: string;\n  timestamp: number;\n}\n\nonViewableItemsChanged?: ((info: {\n    viewableItems: ViewToken[];\n    changed: ViewToken[];\n}) => void) | null | undefined\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Called when the viewability of rows changes, as defined by the ",(0,s.jsx)(n.code,{children:"viewabilityConfig"})," prop. Array of ",(0,s.jsx)(n.code,{children:"changed"})," includes ",(0,s.jsx)(n.code,{children:"ViewToken"}),"s that both visible and non-visible items. You can use the ",(0,s.jsx)(n.code,{children:"isViewable"})," flag to filter the items."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["If you are tracking the time a view becomes (non-)visible, use the ",(0,s.jsx)(n.code,{children:"timestamp"})," property. We make no guarantees that in the future viewability callbacks will be invoked as soon as they happen - for example, they might be deferred until JS thread is less busy."]})}),"\n",(0,s.jsx)(n.h3,{id:"optimizeitemarrangement",children:(0,s.jsx)(n.code,{children:"optimizeItemArrangement"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"optimizeItemArrangement?: boolean;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When enabled with ",(0,s.jsx)(n.code,{children:"masonry"})," layout, this will try to reduce differences in column height by modifying item order. Default is ",(0,s.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"overrideitemlayout",children:(0,s.jsx)(n.code,{children:"overrideItemLayout"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"overrideItemLayout?: (\n    layout: { span?: number;},\n    item: T,\n    index: number,\n    maxColumns: number,\n    extraData?: any\n) => void;\n"})}),"\n",(0,s.jsx)(n.p,{children:"This method can be used to change column span of an item."}),"\n",(0,s.jsx)(n.p,{children:"In v2, span is supported, but size estimates are no longer needed or read."}),"\n",(0,s.jsx)(n.p,{children:"Changing item span is useful when you have grid layouts (numColumns > 1) and you want few items to be bigger than the rest."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<FlashList\n  data={gridData}\n  numColumns={2}\n  overrideItemLayout={(layout, item) => {\n    layout.span = item.span; // Set span\n  }}\n  renderItem={({ item }) => <GridItem item={item} />}\n/>\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"Performance",type:"warning",children:(0,s.jsx)(n.p,{children:"This method is called very frequently. Keep it fast."})}),"\n",(0,s.jsx)(n.h3,{id:"overrideprops",children:(0,s.jsx)(n.code,{children:"overrideProps"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"overrideProps?: object;\n"})}),"\n",(0,s.jsx)(n.p,{children:"We do not recommend using this prop for anything else than debugging. Internal props of the list will be overriden with the provided values."}),"\n",(0,s.jsx)(n.h3,{id:"progressviewoffset",children:(0,s.jsx)(n.code,{children:"progressViewOffset"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"progressViewOffset?: number;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Set this when offset is needed for the loading indicator to show correctly."}),"\n",(0,s.jsx)(n.h3,{id:"refreshcontrol",children:(0,s.jsx)(n.code,{children:"refreshControl"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"refreshControl?: React.ReactElement<any, string | React.JSXElementConstructor<any>>;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A custom refresh control element. When set, it overrides the default ",(0,s.jsx)(n.code,{children:"<RefreshControl>"})," component built internally. The onRefresh and refreshing props are also ignored. Only works for vertical VirtualizedList."]}),"\n",(0,s.jsx)(n.h3,{id:"refreshing",children:(0,s.jsx)(n.code,{children:"refreshing"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"refreshing?: boolean;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Set this true while waiting for new data from a refresh."}),"\n",(0,s.jsx)(n.h3,{id:"renderscrollcomponent",children:(0,s.jsx)(n.code,{children:"renderScrollComponent"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import type { ScrollViewProps } from "react-native";\n\nrenderScrollComponent?:\n    | React.ComponentType<ScrollViewProps>\n    | React.FC<ScrollViewProps>;\n'})}),"\n",(0,s.jsx)(n.p,{children:"Rendered as the main scrollview."}),"\n",(0,s.jsx)(n.h3,{id:"style",children:(0,s.jsx)(n.code,{children:"style"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"style?: StyleProp<ViewStyle>;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Style for the FlashList's parent container. It's highly recommended to avoid adding padding which can impact the size of the ScrollView inside. We operate on the assumption that the size of parent view and ScrollView is the same. In most cases, ",(0,s.jsx)(n.code,{children:"contentContainerStyle"})," should be enough, so avoid using this."]}),"\n",(0,s.jsx)(n.h3,{id:"viewabilityconfig",children:(0,s.jsx)(n.code,{children:"viewabilityConfig"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"interface ViewabilityConfig: {\n  minimumViewTime: number;\n  viewAreaCoveragePercentThreshold: number;\n  itemVisiblePercentThreshold: number;\n  waitForInteraction: boolean;\n}\n\nviewabilityConfig?: ViewabilityConfig;\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"viewabilityConfig"})," is a default configuration for determining whether items are viewable."]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"Changing viewabilityConfig on the fly is not supported"})}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"<FlashList\n    viewabilityConfig={{\n      waitForInteraction: true,\n      itemVisiblePercentThreshold: 50,\n      minimumViewTime: 1000,\n    }}\n  ...\n"})}),"\n",(0,s.jsx)(n.h4,{id:"minimumviewtime",children:"minimumViewTime"}),"\n",(0,s.jsx)(n.p,{children:"Minimum amount of time (in milliseconds) that an item must be physically viewable before the viewability callback will be fired. A high number means that scrolling through content without stopping will not mark the content as viewable. The default value is 250. We do not recommend setting much lower values to preserve performance when quickly scrolling."}),"\n",(0,s.jsx)(n.h4,{id:"viewareacoveragepercentthreshold",children:"viewAreaCoveragePercentThreshold"}),"\n",(0,s.jsx)(n.p,{children:'Percent of viewport that must be covered for a partially occluded item to count as "viewable", 0-100. Fully visible items are always considered viewable. A value of 0 means that a single pixel in the viewport makes the item viewable, and a value of 100 means that an item must be either entirely visible or cover the entire viewport to count as viewable.'}),"\n",(0,s.jsx)(n.h4,{id:"itemvisiblepercentthreshold",children:"itemVisiblePercentThreshold"}),"\n",(0,s.jsxs)(n.p,{children:["Similar to ",(0,s.jsx)(n.code,{children:"viewAreaCoveragePercentThreshold"}),", but considers the percent of the item that is visible, rather than the fraction of the viewable area it covers."]}),"\n",(0,s.jsx)(n.h4,{id:"waitforinteraction",children:"waitForInteraction"}),"\n",(0,s.jsxs)(n.p,{children:["Nothing is considered viewable until the user scrolls or ",(0,s.jsx)(n.code,{children:"recordInteraction"})," is called after render."]}),"\n",(0,s.jsx)(n.h3,{id:"viewabilityconfigcallbackpairs",children:(0,s.jsx)(n.code,{children:"viewabilityConfigCallbackPairs"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"type ViewabilityConfigCallbackPairs = ViewabilityConfigCallbackPair[];\n\ninterface ViewabilityConfigCallbackPair {\n  viewabilityConfig: ViewabilityConfig;\n  onViewableItemsChanged:\n    | ((info: { viewableItems: ViewToken[]; changed: ViewToken[] }) => void)\n    | null;\n}\n\nviewabilityConfigCallbackPairs: ViewabilityConfigCallbackPairs | undefined;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["List of ",(0,s.jsx)(n.code,{children:"ViewabilityConfig"}),"/",(0,s.jsx)(n.code,{children:"onViewableItemsChanged"})," pairs. A specific ",(0,s.jsx)(n.code,{children:"onViewableItemsChanged"})," will be called when its corresponding ",(0,s.jsx)(n.code,{children:"ViewabilityConfig"}),"'s conditions are met."]}),"\n",(0,s.jsx)(n.h1,{id:"hooks",children:"Hooks"}),"\n",(0,s.jsx)(n.h3,{id:"uselayoutstate",children:"useLayoutState"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const [state, setState] = useLayoutState(initialState);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is similar to ",(0,s.jsx)(n.code,{children:"useState"})," but communicates the change in state to FlashList. It's useful if you want to resize a child component based on a local state. Item layout changes will still be detected using ",(0,s.jsx)(n.code,{children:"onLayout"})," callback in the absence of ",(0,s.jsx)(n.code,{children:"useLayoutState"}),", which might not look as smooth on a case-by-case basis."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { useLayoutState } from "@shopify/flash-list";\n\nconst MyItem = ({ item }) => {\n  const [isExpanded, setIsExpanded] = useLayoutState(false);\n  const height = isExpanded ? 150 : 80;\n\n  return (\n    <Pressable onPress={() => setIsExpanded(!isExpanded)}>\n      <View style={{ height, padding: 16 }}>\n        <Text>{item.title}</Text>\n      </View>\n    </Pressable>\n  );\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"userecyclingstate",children:"useRecyclingState"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const [state, setState] = useRecyclingState(\n  initialState,\n  dependencies,\n  resetCallback\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Similar to ",(0,s.jsx)(n.code,{children:"useState"})," but accepts a dependency array. On change of deps, the state gets reset without an additional ",(0,s.jsx)(n.code,{children:"setState"})," call. Useful for maintaining local item state if really necessary. It also has the functionality of ",(0,s.jsx)(n.code,{children:"useLayoutState"})," built in."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { useRecyclingState } from "@shopify/flash-list";\n\nconst GridItem = ({ item }) => {\n  const [isExpanded, setIsExpanded] = useRecyclingState(\n    false,\n    [item.id],\n    () => {\n      // runs on reset. Can be used to reset scroll positions of nested horizontal lists\n    }\n  );\n  const height = isExpanded ? 100 : 50;\n\n  return (\n    <Pressable onPress={() => setIsExpanded(!isExpanded)}>\n      <View style={{ height, backgroundColor: item.color }}>\n        <Text>{item.title}</Text>\n      </View>\n    </Pressable>\n  );\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"usemappinghelper",children:"useMappingHelper"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const { getMappingKey } = useMappingHelper();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Returns a function that helps create a mapping key for items when using ",(0,s.jsx)(n.code,{children:".map()"})," in your render methods. Using this ensures that performance is optimal for FlashList by providing consistent keys that work with the recycling system."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"getMappingKey"})," function takes two parameters:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"index"}),": The index of the item in the array"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"itemKey"}),": A unique identifier for the item (string, number, or bigint)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["It returns the appropriate key value to use in the ",(0,s.jsx)(n.code,{children:"key"})," prop based on the current context."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Basic usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { useMappingHelper } from "@shopify/flash-list";\n\nconst MyComponent = ({ items }) => {\n  const { getMappingKey } = useMappingHelper();\n\n  return (\n    <View>\n      {items.map((item, index) => (\n        <Text key={getMappingKey(item.id, index)}>{item.title}</Text>\n      ))}\n    </View>\n  );\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to use it:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When mapping over arrays to create lists of components inside FlashList items"}),"\n",(0,s.jsx)(n.li,{children:"When building nested components that render multiple items from an array"}),"\n",(0,s.jsx)(n.li,{children:"To ensure consistent key generation that works well with FlashList's recycling system"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"useflashlistcontext",children:"useFlashListContext"}),"\n",(0,s.jsxs)(n.p,{children:["Exposes helpers to easily access ",(0,s.jsx)(n.code,{children:"ref"})," of FlashList. It also exposes ",(0,s.jsx)(n.code,{children:"ref"})," of ScrollView. Ideal for use within child components or ",(0,s.jsx)(n.code,{children:"CellRendererComponent"}),"."]}),"\n",(0,s.jsx)(n.h1,{id:"flashlist-methods",children:"FlashList methods"}),"\n",(0,s.jsx)(n.h3,{id:"prepareforlayoutanimationrender",children:(0,s.jsx)(n.code,{children:"prepareForLayoutAnimationRender()"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"prepareForLayoutAnimationRender(): void;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Run this method before running layout animations, such as when animating an element when deleting it. This method disables recycling for the next frame so that layout animations run well."}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"Avoid using this when making large changes to the data as the list might draw too much to run animations since the method disables recycling temporarily. Single item insertions or deletions should animate smoothly. The render after animation will enable recycling again and you can stop avoiding making large data changes."})}),"\n",(0,s.jsx)(n.h3,{id:"recordinteraction",children:(0,s.jsx)(n.code,{children:"recordInteraction()"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"recordInteraction();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Tells the list an interaction has occurred, which should trigger viewability calculations, e.g. if ",(0,s.jsx)(n.code,{children:"waitForInteractions"})," is true and the user has not scrolled. You should typically call ",(0,s.jsx)(n.code,{children:"recordInteraction()"})," when user for example taps on an item or invokes a navigation action."]}),"\n",(0,s.jsx)(n.h3,{id:"recomputeviewableitems",children:(0,s.jsx)(n.code,{children:"recomputeViewableItems()"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"recomputeViewableItems();\n"})}),"\n",(0,s.jsx)(n.p,{children:"Retriggers viewability calculations. Useful to imperatively trigger viewability calculations."}),"\n",(0,s.jsx)(n.h3,{id:"scrolltoend",children:(0,s.jsx)(n.code,{children:"scrollToEnd()"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"scrollToEnd?: (params?: { animated?: boolean | null | undefined });\n"})}),"\n",(0,s.jsx)(n.p,{children:"Scrolls to the end of the content."}),"\n",(0,s.jsx)(n.h3,{id:"scrolltoindex",children:(0,s.jsx)(n.code,{children:"scrollToIndex()"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"scrollToIndex(params: {\n  animated?: boolean | null | undefined;\n  index: number;\n  viewOffset?: number | undefined;\n  viewPosition?: number | undefined;\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Scroll to a given index."}),"\n",(0,s.jsx)(n.h3,{id:"scrolltoitem",children:(0,s.jsx)(n.code,{children:"scrollToItem()"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"scrollToItem(params: {\n  animated?: boolean | null | undefined;\n  item: any;\n  viewPosition?: number | undefined;\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Scroll to a given item."}),"\n",(0,s.jsx)(n.h3,{id:"scrolltooffset",children:(0,s.jsx)(n.code,{children:"scrollToOffset()"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"scrollToOffset(params: {\n  animated?: boolean | null | undefined;\n  offset: number;\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Scroll to a specific content pixel offset in the list."}),"\n",(0,s.jsxs)(n.p,{children:["Param ",(0,s.jsx)(n.code,{children:"offset"})," expects the offset to scroll to. In case of ",(0,s.jsx)(n.code,{children:"horizontal"})," is true, the offset is the x-value, in any other case the offset is the y-value."]}),"\n",(0,s.jsxs)(n.p,{children:["Param ",(0,s.jsx)(n.code,{children:"animated"})," (",(0,s.jsx)(n.code,{children:"false"})," by default) defines whether the list should do an animation while scrolling."]}),"\n",(0,s.jsx)(n.h3,{id:"getvisibleindices",children:(0,s.jsx)(n.code,{children:"getVisibleIndices()"})}),"\n",(0,s.jsx)(n.p,{children:"Returns an array of indices that are currently visible in the list."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"getVisibleIndices(): number[];\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getlayout",children:(0,s.jsx)(n.code,{children:"getLayout()"})}),"\n",(0,s.jsx)(n.p,{children:"Returns the current layout information for the list."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"getLayout(): { x: number, y: number, width: number; height: number };\n"})}),"\n",(0,s.jsx)(n.h3,{id:"flashscrollindicators",children:(0,s.jsx)(n.code,{children:"flashScrollIndicators()"})}),"\n",(0,s.jsx)(n.p,{children:"Shows the scroll indicators momentarily."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"flashScrollIndicators(): void;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getnativescrollref",children:(0,s.jsx)(n.code,{children:"getNativeScrollRef()"})}),"\n",(0,s.jsx)(n.p,{children:"Returns a reference to the underlying scroll view."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"getNativeScrollRef(): React.RefObject<CompatScroller>;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getscrollresponder",children:(0,s.jsx)(n.code,{children:"getScrollResponder()"})}),"\n",(0,s.jsx)(n.p,{children:"Returns the scroll responder of the underlying scroll view."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"getScrollResponder(): any;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getscrollablenode",children:(0,s.jsx)(n.code,{children:"getScrollableNode()"})}),"\n",(0,s.jsx)(n.p,{children:"Returns the native scrollable node of the underlying scroll view."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"getScrollableNode(): any;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scrolltotop",children:(0,s.jsx)(n.code,{children:"scrollToTop()"})}),"\n",(0,s.jsx)(n.p,{children:"Scrolls to the top of the list."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"scrollToTop(params?: { animated?: boolean }): void;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getfirstitemoffset",children:(0,s.jsx)(n.code,{children:"getFirstItemOffset()"})}),"\n",(0,s.jsx)(n.p,{children:"Returns the offset of the first item (useful for calculating header size or top padding)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"getFirstItemOffset(): number;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getwindowsize",children:(0,s.jsx)(n.code,{children:"getWindowSize()"})}),"\n",(0,s.jsx)(n.p,{children:"Returns the current rendered dimensions of the list."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"getWindowSize(): { width: number, height: number };\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getfirstvisibleindex",children:(0,s.jsx)(n.code,{children:"getFirstVisibleIndex()"})}),"\n",(0,s.jsx)(n.p,{children:"Returns the index of the first visible item in the list."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"getFirstVisibleIndex(): number;\n"})}),"\n",(0,s.jsx)(n.h1,{id:"scrollview-props",children:"ScrollView props"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"FlashList"}),", as ",(0,s.jsx)(n.code,{children:"FlatList"}),", uses ",(0,s.jsx)(n.code,{children:"ScrollView"})," under the hood. You can take a look into the React Native documentation for ",(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/scrollview",children:(0,s.jsx)(n.code,{children:"ScrollView"})})," to see the exhaustive list of props."]}),"\n",(0,s.jsxs)(n.h1,{id:"unsupported-flatlist-props",children:["Unsupported ",(0,s.jsx)(n.code,{children:"FlatList"})," props"]}),"\n",(0,s.jsxs)(n.p,{children:["The following props from ",(0,s.jsx)(n.code,{children:"FlatList"})," are currently not implemented:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/flatlist#columnwrapperstyle",children:(0,s.jsx)(n.code,{children:"columnWrapperStyle"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/virtualizedlist#debug",children:(0,s.jsx)(n.code,{children:"debug"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/virtualizedlist#listkey",children:(0,s.jsx)(n.code,{children:"listKey"})})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["There are also ",(0,s.jsx)(n.code,{children:"FlatList"})," props that would bring no value if ported to ",(0,s.jsx)(n.code,{children:"FlashList"})," due to the differences in their underlying implementation:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/virtualizedlist#disablevirtualization",children:(0,s.jsx)(n.code,{children:"disableVirtualization"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/flatlist#getItemLayout",children:(0,s.jsx)(n.code,{children:"getItemLayout"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/flatlist#initialnumtorender",children:(0,s.jsx)(n.code,{children:"initialNumToRender"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/virtualizedlist#maxtorenderperbatch",children:(0,s.jsx)(n.code,{children:"maxToRenderPerBatch"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/virtualizedlist#recordinteraction",children:(0,s.jsx)(n.code,{children:"recordInteraction"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/virtualizedlist#setnativeprops",children:(0,s.jsx)(n.code,{children:"setNativeProps"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/virtualizedlist#updatecellsbatchingperiod",children:(0,s.jsx)(n.code,{children:"updateCellsBatchingPeriod"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/virtualizedlist#onscrolltoindexfailed",children:(0,s.jsx)(n.code,{children:"onScrollToIndexFailed"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/virtualizedlist#windowsize",children:(0,s.jsx)(n.code,{children:"windowSize"})})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We don't currently plan to implement these props."})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>r});var t=i(6540);const s={},l=t.createContext(s);function o(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);