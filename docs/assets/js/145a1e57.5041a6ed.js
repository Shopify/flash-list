"use strict";(self.webpackChunkflash_list=self.webpackChunkflash_list||[]).push([[380],{2723:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"2.x","banner":null,"badge":true,"noIndex":false,"className":"docs-version-current","isLast":false,"docsSidebars":{"autoSidebar":[{"type":"link","label":"Introduction \ud83d\udcda","href":"/flash-list/docs/","docId":"introduction","unlisted":false},{"type":"category","label":"Fundamentals","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Usage","href":"/flash-list/docs/usage","docId":"fundamentals/usage","unlisted":false},{"type":"link","label":"Layout Commit Observer","href":"/flash-list/docs/fundamentals/layout-commit-observer","docId":"fundamentals/layout-commit-observer","unlisted":false},{"type":"link","label":"Performance","href":"/flash-list/docs/fundamentals/performance","docId":"fundamentals/performance","unlisted":false},{"type":"link","label":"Recycling","href":"/flash-list/docs/recycling","docId":"fundamentals/recycling","unlisted":false}]},{"type":"category","label":"Guides","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"LayoutAnimation","href":"/flash-list/docs/guides/layout-animation","docId":"guides/layout-animation","unlisted":false},{"type":"link","label":"Masonry Layout","href":"/flash-list/docs/guides/masonry","docId":"guides/masonry","unlisted":false},{"type":"link","label":"React Native Reanimated","href":"/flash-list/docs/guides/reanimated","docId":"guides/reanimated","unlisted":false},{"type":"link","label":"SectionList","href":"/flash-list/docs/guides/section-list","docId":"guides/section-list","unlisted":false},{"type":"link","label":"Testing with Jest","href":"/flash-list/docs/testing","docId":"guides/testing","unlisted":false}]},{"type":"link","label":"Known issues","href":"/flash-list/docs/known-issues","docId":"known-issues","unlisted":false},{"type":"link","label":"What\'s new in v2","href":"/flash-list/docs/v2-changes","docId":"v2-changes","unlisted":false},{"type":"link","label":"Migrating to v2","href":"/flash-list/docs/v2-migration","docId":"v2-migration","unlisted":false}]},"docs":{"fundamentals/layout-commit-observer":{"id":"fundamentals/layout-commit-observer","title":"Layout Commit Observer","description":"The LayoutCommitObserver is a utility component that helps you track when all FlashList components in your component tree have completed their layout. This is particularly useful for coordinating complex UI behaviors that depend on list rendering completion. Doing your own setState in this callback will block paint till your state change is ready to be committed.","sidebar":"autoSidebar"},"fundamentals/performance":{"id":"fundamentals/performance","title":"Performance","description":"Profiling","sidebar":"autoSidebar"},"fundamentals/recycling":{"id":"fundamentals/recycling","title":"Recycling","description":"One important thing to understand is how FlashList works under the hood. When an item gets out of the viewport, instead of being destroyed, the component is re-rendered with a different item prop. For example, if you make use of useState in a reused component, you may see state values that were set for that component when it was associated with a different item in the list, and would then need to reset any previously set state when a new item is rendered.","sidebar":"autoSidebar"},"fundamentals/usage":{"id":"fundamentals/usage","title":"Usage","description":"If you are familiar with FlatList, you already know how to use FlashList. You can try out FlashList by changing the component name.","sidebar":"autoSidebar"},"guides/layout-animation":{"id":"guides/layout-animation","title":"LayoutAnimation","description":"LayoutAnimation is a popular way how to animate views in React Native.","sidebar":"autoSidebar"},"guides/masonry":{"id":"guides/masonry","title":"Masonry Layout","description":"Masonry Layout allows you to create a grid of items with different heights. It is a great way to display a collection of images with different sizes.","sidebar":"autoSidebar"},"guides/reanimated":{"id":"guides/reanimated","title":"React Native Reanimated","description":"React Native Reanimated is an alternative animation library to the LayoutAnimation API provided by React Native.","sidebar":"autoSidebar"},"guides/section-list":{"id":"guides/section-list","title":"SectionList","description":"React Native has a convenience component on top of FlatList, called SectionList. This component has some additional props:","sidebar":"autoSidebar"},"guides/testing":{"id":"guides/testing","title":"Testing with Jest","description":"By default FlashList will mount all items in the test environment. You can use the following mock to setup measurements to prevent everything from mounting. You can also create your own mock.","sidebar":"autoSidebar"},"introduction":{"id":"introduction","title":"Introduction \ud83d\udcda","description":"Fast & performant React Native list. No more blank cells.","sidebar":"autoSidebar"},"known-issues":{"id":"known-issues","title":"Known issues","description":"FlashList and FlatList have very different internals. While the API is almost the same, the behaviour might be different in some cases due to a bug, limitation or missing implementation. In any case, if the issue is already listed here don\'t create a new one.","sidebar":"autoSidebar"},"v2-changes":{"id":"v2-changes","title":"What\'s new in v2","description":"New props","sidebar":"autoSidebar"},"v2-migration":{"id":"v2-migration","title":"Migrating to v2","description":"This guide will help you migrate your existing FlashList v1 implementation to v2. FlashList v2 brings significant improvements in performance, developer experience, and new features while removing some deprecated props.","sidebar":"autoSidebar"}}}}')}}]);