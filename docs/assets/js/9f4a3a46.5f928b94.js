"use strict";(self.webpackChunkflash_list=self.webpackChunkflash_list||[]).push([[489],{2637:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"v2-changes","title":"What\'s new in v2","description":"New props","source":"@site/docs/v2-changes.md","sourceDirName":".","slug":"/v2-changes","permalink":"/flash-list/docs/v2-changes","draft":false,"unlisted":false,"editUrl":"https://github.com/Shopify/flash-list/blob/main/documentation/docs/v2-changes.md","tags":[],"version":"current","lastUpdatedBy":"Bartosz Kaszubowski","lastUpdatedAt":1757634122000,"sidebarPosition":4,"frontMatter":{"id":"v2-changes","title":"What\'s new in v2","slug":"/v2-changes","sidebar_position":4},"sidebar":"autoSidebar","previous":{"title":"Known issues","permalink":"/flash-list/docs/known-issues"},"next":{"title":"Migrating to v2","permalink":"/flash-list/docs/v2-migration"}}');var i=s(4848),o=s(8453);const l={id:"v2-changes",title:"What's new in v2",slug:"/v2-changes",sidebar_position:4},a=void 0,r={},d=[{value:"New props",id:"new-props",level:2},{value:"Changed props",id:"changed-props",level:2},{value:"New features",id:"new-features",level:2},{value:"Improvements",id:"improvements",level:2},{value:"New hooks",id:"new-hooks",level:2},{value:"useLayoutState",id:"uselayoutstate",level:3},{value:"useRecyclingState",id:"userecyclingstate",level:3},{value:"useMappingHelper",id:"usemappinghelper",level:3},{value:"useFlashListContext",id:"useflashlistcontext",level:3},{value:"New helper components",id:"new-helper-components",level:2},{value:"LayoutCommitObserver",id:"layoutcommitobserver",level:3},{value:"Deprecated",id:"deprecated",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"new-props",children:"New props"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"masonry"}),": Enable masonry layout for grid-like interfaces with varying item heights."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"<FlashList\n  data={data}\n  masonry\n  numColumns={3}\n  renderItem={({ item }) => <MasonryItem item={item} />}\n/>\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"optimizeItemArrangement"}),": When enabled, masonry layout will try to reduce differences in column height by modifying item order."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"onStartReached"}),": Called when the scroll position gets within ",(0,i.jsx)(n.code,{children:"onStartReachedThreshold"})," of the start of the content."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"<FlashList\n  data={messageData}\n  onStartReached={() => loadOlderMessages()}\n  onStartReachedThreshold={0.1}\n  renderItem={({ item }) => <MessageItem message={item} />}\n/>\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"onStartReachedThreshold"}),": How far from the start the top edge of the list must be to trigger ",(0,i.jsx)(n.code,{children:"onStartReached"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"maxItemsInRecyclePool"}),": Maximum number of items in the recycle pool (Not required unless the number of item types is huge)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"style"}),": Style for the FlashList's parent container. We highly recommend not adding padding which can impact the size of the ScrollView inside. We operate on the assumption that the size of parent view and ScrollView is the same. In most cases, ",(0,i.jsx)(n.code,{children:"contentContainerStyle"})," should be enough so avoid using this."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"maintainVisibleContentPosition"}),": Configuration for maintaining scroll position when content changes:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"disabled"}),": Set to true to disable this feature (enabled by default)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"autoscrollToTopThreshold"}),": Automatically scroll to maintain position when content is added at the top."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"autoscrollToBottomThreshold"}),": Automatically scroll to maintain position when content is added at the bottom."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"animateAutoScrollToBottom"}),": Scroll with animation whenever ",(0,i.jsx)(n.code,{children:"autoscrollToBottom"})," is triggered. Default is ",(0,i.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"startRenderingFromBottom"}),": If true, initial render will start from the bottom, useful for chat interfaces."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"<FlashList\n  data={chatMessages}\n  maintainVisibleContentPosition={{\n    autoscrollToBottomThreshold: 0.2,\n    startRenderingFromBottom: true,\n  }}\n  renderItem={({ item }) => <ChatMessage message={item} />}\n/>\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"onCommitLayoutEffect"}),": Called before layout is committed. Can be used to measure list and make changes before paint. Doing setState inside the callback can lead to infinite loops. Make sure FlashList's props are memoized."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"changed-props",children:"Changed props"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"overrideItemLayout"}),": This used to allow a way to change the span of items and provide size estimates. In v2, span is supported, but we no longer read the size estimates.","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"<FlashList\n  data={gridData}\n  numColumns={2}\n  overrideItemLayout={(layout, item) => {\n    layout.span = item.span; // Set span\n  }}\n  renderItem={({ item }) => <GridItem item={item} />}\n/>\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"new-features",children:"New features"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"masonry"})," is now a prop on FlashList. It's now also possible to use ",(0,i.jsx)(n.code,{children:"overrideItemLayout"})," with ",(0,i.jsx)(n.code,{children:"masonry"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"maintainVisibleContentPosition"})," is available and now enabled by default. We use this to reduce visible glitches as much as possible. Chat apps without inverted will also be possible. Please note that if you plan on adding a large number of rows on top of the list, then you may want to increase the drawDistance on the list."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"onStartReached"})," callback is now available with a configurable threshold."]}),"\n",(0,i.jsx)(n.li,{children:"We've also added support for RTL layouts."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"improvements",children:"Improvements"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"scrollToIndex"})," and ",(0,i.jsx)(n.code,{children:"scrollToItem"})," are much more precise."]}),"\n",(0,i.jsx)(n.li,{children:"Scrolling upwards after orientation change doesn't cause layout glitches. The same is true for scrolling to items and scrolling upwards."}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"stickyHeaders"})," use an Animated implementation, so minor gaps between them while scrolling aren't visible anymore."]}),"\n",(0,i.jsx)(n.li,{children:"FlashList does not ask for any estimates, which makes it much easier to use."}),"\n",(0,i.jsx)(n.li,{children:"Horizontal Lists are much improved, and items can also resize within the lists. We no longer render an extra item to measure list height."}),"\n",(0,i.jsx)(n.li,{children:"In Grid layout, if side-by-side items have different heights, then the shorter item will match the height of the tallest item. This wasn't possible in v1."}),"\n",(0,i.jsxs)(n.li,{children:["The ref of FlashList has many more useful methods like ",(0,i.jsx)(n.code,{children:"getVisibleIndices"})," and ",(0,i.jsx)(n.code,{children:"getLayout"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"contentContainerStyle"})," prop is fully supported now."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"new-hooks",children:"New hooks"}),"\n",(0,i.jsx)(n.h3,{id:"uselayoutstate",children:"useLayoutState"}),"\n",(0,i.jsxs)(n.p,{children:["This is similar to ",(0,i.jsx)(n.code,{children:"useState"})," but communicates the change in state to FlashList. It's useful if you want to resize a child component based on a local state. Item layout changes will still be detected using ",(0,i.jsx)(n.code,{children:"onLayout"})," callback in the absence of ",(0,i.jsx)(n.code,{children:"useLayoutState"}),", which might not look as smooth on a case-by-case basis."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { useLayoutState } from "@shopify/flash-list";\n\nconst MyItem = ({ item }) => {\n  const [isExpanded, setIsExpanded] = useLayoutState(false);\n  const height = isExpanded ? 150 : 80;\n\n  return (\n    <Pressable onPress={() => setIsExpanded(!isExpanded)}>\n      <View style={{ height, padding: 16 }}>\n        <Text>{item.title}</Text>\n      </View>\n    </Pressable>\n  );\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"userecyclingstate",children:"useRecyclingState"}),"\n",(0,i.jsxs)(n.p,{children:["Similar to ",(0,i.jsx)(n.code,{children:"useState"})," but accepts a dependency array. On change of deps, the state gets reset without an additional ",(0,i.jsx)(n.code,{children:"setState"})," call. Useful for maintaining local item state if really necessary. It also has the functionality of ",(0,i.jsx)(n.code,{children:"useLayoutState"})," built in."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { useRecyclingState } from "@shopify/flash-list";\n\nconst GridItem = ({ item }) => {\n  const [isExpanded, setIsExpanded] = useRecyclingState(\n    false,\n    [item.id],\n    () => {\n      // runs on reset. Can be used to reset scroll positions of nested horizontal lists\n    }\n  );\n  const height = isExpanded ? 100 : 50;\n\n  return (\n    <Pressable onPress={() => setIsExpanded(!isExpanded)}>\n      <View style={{ height, backgroundColor: item.color }}>\n        <Text>{item.title}</Text>\n      </View>\n    </Pressable>\n  );\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"usemappinghelper",children:"useMappingHelper"}),"\n",(0,i.jsxs)(n.p,{children:["Returns a function that helps create optimal mapping keys for items when using ",(0,i.jsx)(n.code,{children:".map()"})," in your render methods. Using this ensures optimized recycling and performance for FlashList."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { useMappingHelper } from "@shopify/flash-list";\n\nconst MyComponent = ({ items }) => {\n  const { getMappingKey } = useMappingHelper();\n\n  return (\n    <FlashList\n      data={items}\n      renderItem={({ item }) => <ItemComponent item={item} />}\n    />\n  );\n};\n\n// When mapping over items inside components:\nconst NestedList = ({ items }) => {\n  const { getMappingKey } = useMappingHelper();\n\n  return (\n    <View>\n      {items.map((item, index) => (\n        <Text key={getMappingKey(item.id, index)}>{item.title}</Text>\n      ))}\n    </View>\n  );\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"useflashlistcontext",children:"useFlashListContext"}),"\n",(0,i.jsxs)(n.p,{children:["Exposes helpers to easily access ",(0,i.jsx)(n.code,{children:"ref"})," of FlashList. It also exposes ",(0,i.jsx)(n.code,{children:"ref"})," of ScrollView. Ideal for use within child components or ",(0,i.jsx)(n.code,{children:"CellRendererComponent"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"new-helper-components",children:"New helper components"}),"\n",(0,i.jsx)(n.h3,{id:"layoutcommitobserver",children:"LayoutCommitObserver"}),"\n",(0,i.jsx)(n.p,{children:"A component that observes when FlashList commits a layout. This is particularly useful when you have one or more FlashLists somewhere down the component tree and need to know when all of them have finished their layout commit."}),"\n",(0,i.jsxs)(n.p,{children:["Read more ",(0,i.jsx)(n.a,{href:"/flash-list/docs/fundamentals/layout-commit-observer",children:"here."})]}),"\n",(0,i.jsx)(n.h2,{id:"deprecated",children:"Deprecated"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"estimatedItemSize"}),": No longer used."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"estimatedListSize"}),": No longer used."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"estimatedFirstItemOffset"}),": No longer used."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"inverted"}),": We have added ",(0,i.jsx)(n.code,{children:"maintainVisibleContentPosition"})," support, so we don't want to maintain inverted mode."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"onBlankArea"}),": We don't have plans to add or continue supporting this prop."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"disableHorizontalListHeightMeasurement"}),": No longer needed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"disableAutoLayout"}),": There's no auto layout in v2."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"MasonryFlashList"})," will be replaced by ",(0,i.jsx)(n.code,{children:"masonry"})," prop."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"getColumnFlex"})," from ",(0,i.jsx)(n.code,{children:"MasonryFlashList"})," will not be supported in FlashList v2 with ",(0,i.jsx)(n.code,{children:"masonry"})," prop."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>a});var t=s(6540);const i={},o=t.createContext(i);function l(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);