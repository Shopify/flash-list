"use strict";(self.webpackChunkflash_list=self.webpackChunkflash_list||[]).push([[706],{8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>r});var i=s(6540);const n={},a=i.createContext(n);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),i.createElement(a.Provider,{value:t},e.children)}},8623:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"known-issues","title":"Known issues","description":"FlashList and FlatList have very different internals. While the API is almost the same, the behaviour might be different in some cases due to a bug, limitation or missing implementation. In any case, if the issue is already listed here don\'t create a new one.","source":"@site/docs/known-issues.md","sourceDirName":".","slug":"/known-issues","permalink":"/flash-list/docs/known-issues","draft":false,"unlisted":false,"editUrl":"https://github.com/Shopify/flash-list/blob/main/documentation/docs/known-issues.md","tags":[],"version":"current","lastUpdatedBy":"Bartosz Kaszubowski","lastUpdatedAt":1757634122000,"sidebarPosition":3,"frontMatter":{"id":"known-issues","title":"Known issues","slug":"/known-issues","sidebar_position":3},"sidebar":"autoSidebar","previous":{"title":"Testing with Jest","permalink":"/flash-list/docs/testing"},"next":{"title":"What\'s new in v2","permalink":"/flash-list/docs/v2-changes"}}');var n=s(4848),a=s(8453);const o={id:"known-issues",title:"Known issues",slug:"/known-issues",sidebar_position:3},r="Known Issues",l={},d=[{value:"1) Horizontal lists + RTL Layout",id:"1-horizontal-lists--rtl-layout",level:3},{value:"2) Horizontal Lists with headers",id:"2-horizontal-lists-with-headers",level:3},{value:"3) Data re-ordering can cause items to move",id:"3-data-re-ordering-can-cause-items-to-move",level:3}];function h(e){const t={code:"code",h1:"h1",h3:"h3",header:"header",p:"p",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"known-issues",children:"Known Issues"})}),"\n",(0,n.jsx)(t.p,{children:"FlashList and FlatList have very different internals. While the API is almost the same, the behaviour might be different in some cases due to a bug, limitation or missing implementation. In any case, if the issue is already listed here don't create a new one."}),"\n",(0,n.jsx)(t.h3,{id:"1-horizontal-lists--rtl-layout",children:"1) Horizontal lists + RTL Layout"}),"\n",(0,n.jsxs)(t.p,{children:["We have a limitation where we're not able to read the padding applied on the list using ",(0,n.jsx)(t.code,{children:"contentContainerStyle"}),". Small values shouldn't cause an issue; however, if you require precise ",(0,n.jsx)(t.code,{children:"scrollTo"})," or ",(0,n.jsx)(t.code,{children:"initialScrollIndex"}),", then apply padding or margin to the header instead. Please note that this applies only to RTL language layouts."]}),"\n",(0,n.jsx)(t.h3,{id:"2-horizontal-lists-with-headers",children:"2) Horizontal Lists with headers"}),"\n",(0,n.jsxs)(t.p,{children:["If the horizontal list has a fixed size or header, we assume that the height of the list is fixed. If your use case requires the list to match the size of the items or resize based on tallest child, just skip using the header. You can just render the header as the first item in the list and give it a separate type using ",(0,n.jsx)(t.code,{children:"getItemType"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"3-data-re-ordering-can-cause-items-to-move",children:"3) Data re-ordering can cause items to move"}),"\n",(0,n.jsxs)(t.p,{children:["This is because ",(0,n.jsx)(t.code,{children:"maintainVisibleContentPosition"})," is enabled by default. If you're running into this then you can disable it by setting ",(0,n.jsx)(t.code,{children:"maintainVisibleContentPosition={{disabled:true}}"}),". Having it enabled by default allows us to handle any layout changes while scrolling upwards in a better way like after an orientation change or a large scroll jump to the last item."]})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}}}]);