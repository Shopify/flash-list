"use strict";(self.webpackChunkflash_list=self.webpackChunkflash_list||[]).push([[260],{7103:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"guides/layout-animation","title":"LayoutAnimation","description":"LayoutAnimation is a popular way how to animate views in React Native.","source":"@site/versioned_docs/version-1.x/guides/layout-animation.md","sourceDirName":"guides","slug":"/guides/layout-animation","permalink":"/flash-list/docs/1.x/guides/layout-animation","draft":false,"unlisted":false,"editUrl":"https://github.com/Shopify/flash-list/blob/main/documentation/versioned_docs/version-1.x/guides/layout-animation.md","tags":[],"version":"1.x","lastUpdatedBy":"Bartosz Kaszubowski","lastUpdatedAt":1757634122000,"frontMatter":{"id":"layout-animation","title":"LayoutAnimation"},"sidebar":"autoSidebar","previous":{"title":"Recycling","permalink":"/flash-list/docs/1.x/recycling"},"next":{"title":"Manual linking","permalink":"/flash-list/docs/1.x/guides/manual-linking"}}');var a=n(4848),o=n(8453);const r={id:"layout-animation",title:"LayoutAnimation"},s=void 0,l={},d=[{value:"Example",id:"example",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://reactnative.dev/docs/layoutanimation",children:(0,a.jsx)(t.code,{children:"LayoutAnimation"})})," is a popular way how to animate views in React Native."]}),"\n",(0,a.jsxs)(t.p,{children:["FlashList does support ",(0,a.jsx)(t.code,{children:"LayoutAnimation"}),"s but you need to call ",(0,a.jsx)(t.a,{href:"/flash-list/docs/1.x/usage#prepareforlayoutanimationrender",children:(0,a.jsx)(t.code,{children:"prepareForLayoutAnimationRender()"})})," before React Native's ",(0,a.jsx)(t.a,{href:"https://reactnative.dev/docs/layoutanimation#configurenext",children:(0,a.jsx)(t.code,{children:"LayoutAnimation.configureNext"})}),". ",(0,a.jsx)(t.code,{children:"prepareForLayoutAnimationRender"})," is an instance method, so you have to keep a reference to your ",(0,a.jsx)(t.code,{children:"FlashList"})," instance via the ",(0,a.jsx)(t.a,{href:"https://reactjs.org/docs/refs-and-the-dom.html",children:(0,a.jsx)(t.code,{children:"ref"})})," prop:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:"// This must be called before `LayoutAnimation.configureNext` in order for the animation to run properly.\nlistRef.current?.prepareForLayoutAnimationRender();\n// After removing the item, we can start the animation.\nLayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["For the animation to work properly, you additionally need to add ",(0,a.jsx)(t.a,{href:"/flash-list/docs/1.x/usage#keyextractor",children:(0,a.jsx)(t.code,{children:"keyExtractor"})})," prop to your ",(0,a.jsx)(t.code,{children:"FlashList"})," component if you have not already done so."]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"LayoutAnimation"})," is experimental on Android, so we cannot guarantee its stability when used with ",(0,a.jsx)(t.code,{children:"FlashList"}),"."]})}),"\n",(0,a.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:'import React, { useRef, useState } from "react";\nimport { View, Text, Pressable, LayoutAnimation } from "react-native";\nimport { FlashList } from "@shopify/flash-list";\n\nconst List = () => {\n  const [data, setData] = useState([1, 2, 3, 4, 5]);\n\n  const list = useRef<FlashList<number> | null>(null);\n\n  const removeItem = (item: number) => {\n    setData(\n      data.filter((dataItem) => {\n        return dataItem !== item;\n      })\n    );\n    // This must be called before `LayoutAnimation.configureNext` in order for the animation to run properly.\n    list.current?.prepareForLayoutAnimationRender();\n    // After removing the item, we can start the animation.\n    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);\n  };\n\n  const renderItem = ({ item }: { item: number }) => {\n    return (\n      <Pressable\n        onPress={() => {\n          removeItem(item);\n        }}\n      >\n        <View>\n          <Text>Cell Id: {item}</Text>\n        </View>\n      </Pressable>\n    );\n  };\n\n  return (\n    <FlashList\n      // Saving reference to the `FlashList` instance to later trigger `prepareForLayoutAnimationRender` method.\n      ref={list}\n      // This prop is necessary to uniquely identify the elements in the list.\n      keyExtractor={(item: number) => {\n        return item.toString();\n      }}\n      renderItem={renderItem}\n      estimatedItemSize={100}\n      data={data}\n    />\n  );\n};\n\nexport default List;\n'})})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var i=n(6540);const a={},o=i.createContext(a);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);