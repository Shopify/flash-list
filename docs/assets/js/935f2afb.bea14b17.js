"use strict";(self.webpackChunkflash_list=self.webpackChunkflash_list||[]).push([[581],{5610:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"autoSidebar":[{"type":"link","label":"Introduction \ud83d\udcda","href":"/flash-list/docs/","docId":"introduction"},{"type":"category","label":"Fundamentals","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Usage","href":"/flash-list/docs/usage","docId":"fundamentals/usage"},{"type":"link","label":"Metrics","href":"/flash-list/docs/metrics","docId":"fundamentals/metrics"},{"type":"link","label":"Performance troubleshooting","href":"/flash-list/docs/performance-troubleshooting","docId":"fundamentals/performance-troubleshooting"},{"type":"link","label":"Estimated Item Size Prop","href":"/flash-list/docs/estimated-item-size","docId":"fundamentals/estimated-item-size"},{"type":"link","label":"Writing performant components","href":"/flash-list/docs/fundamentals/performant-components","docId":"fundamentals/performant-components"},{"type":"link","label":"Recycling","href":"/flash-list/docs/recycling","docId":"fundamentals/recycling"}]},{"type":"category","label":"Guides","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"LayoutAnimation","href":"/flash-list/docs/guides/layout-animation","docId":"guides/layout-animation"},{"type":"link","label":"Manual linking","href":"/flash-list/docs/guides/manual-linking","docId":"guides/manual-linking"},{"type":"link","label":"Masonry Layout","href":"/flash-list/docs/guides/masonry","docId":"guides/masonry"},{"type":"link","label":"React Native Reanimated","href":"/flash-list/docs/guides/reanimated","docId":"guides/reanimated"},{"type":"link","label":"SectionList","href":"/flash-list/docs/guides/section-list","docId":"guides/section-list"},{"type":"link","label":"Testing with Jest","href":"/flash-list/docs/testing","docId":"guides/testing"}]},{"type":"link","label":"Known issues","href":"/flash-list/docs/known-issues","docId":"known-issues"}]},"docs":{"fundamentals/estimated-item-size":{"id":"fundamentals/estimated-item-size","title":"Estimated Item Size Prop","description":"estimatedItemSize is a single numeric value that hints FlashList about the approximate size of the items before they\'re rendered. FlashList can then use this information to decide how many items it needs to draw on the screen before initial load and while scrolling. If most of the items are of different sizes, you can think of an average or median value and if most items are of the same size, just use that number. A quick look at Element Inspector can help you determine this. If you\'re confused between two values, the smaller value is a better choice.","sidebar":"autoSidebar"},"fundamentals/metrics":{"id":"fundamentals/metrics","title":"Metrics","description":"FlashList enables you to track metrics in production that can give you more insight into how your app is doing in terms of performance. We recommend that you track the following in production:","sidebar":"autoSidebar"},"fundamentals/performance-troubleshooting":{"id":"fundamentals/performance-troubleshooting","title":"Performance troubleshooting","description":"Profiling","sidebar":"autoSidebar"},"fundamentals/performant-components":{"id":"fundamentals/performant-components","title":"Writing performant components","description":"While FlashList does its best to achieve high performance, it will still perform poorly if your item components are slow to render. In this post, let\'s dive deeper into how you can remedy this.","sidebar":"autoSidebar"},"fundamentals/recycling":{"id":"fundamentals/recycling","title":"Recycling","description":"One important thing to understand is how FlashList works under the hood. When an item gets out of the viewport, instead of being destroyed, the component is re-rendered with a different item prop. For example, if you make use of useState in a reused component, you may see state values that were set for that component when it was associated with a different item in the list, and would then need to reset any previously set state when a new item is rendered:","sidebar":"autoSidebar"},"fundamentals/usage":{"id":"fundamentals/usage","title":"Usage","description":"If you are familiar with FlatList, you already know how to use FlashList. You can try out FlashList by changing the component name and adding the estimatedItemSize prop or refer to the example below:","sidebar":"autoSidebar"},"guides/layout-animation":{"id":"guides/layout-animation","title":"LayoutAnimation","description":"LayoutAnimation is a popular way how to animate views in React Native.","sidebar":"autoSidebar"},"guides/manual-linking":{"id":"guides/manual-linking","title":"Manual linking","description":"iOS","sidebar":"autoSidebar"},"guides/masonry":{"id":"guides/masonry","title":"Masonry Layout","description":"Masonry Layout allows you to create a grid of items with different heights. It is a great way to display a collection of images with different sizes.","sidebar":"autoSidebar"},"guides/reanimated":{"id":"guides/reanimated","title":"React Native Reanimated","description":"React Native Reanimated is an alternative animation library to the LayoutAnimation API provided by React Native.","sidebar":"autoSidebar"},"guides/section-list":{"id":"guides/section-list","title":"SectionList","description":"React Native has a convenience component on top of FlatList, called SectionList. This component has some additional props:","sidebar":"autoSidebar"},"guides/testing":{"id":"guides/testing","title":"Testing with Jest","description":"Since FlashList does not immediately render but waits for the size of the underlying ScrollView (unless you specify estimatedListSize), we need to mock triggering onLayout event.","sidebar":"autoSidebar"},"introduction":{"id":"introduction","title":"Introduction \ud83d\udcda","description":"Fast & performant React Native list. No more blank cells.","sidebar":"autoSidebar"},"known-issues":{"id":"known-issues","title":"Known issues","description":"FlashList and FlatList have very different internal. While the API is almost the same, the behaviour might be different in some cases due to a bug, limitation or missing implementation. In any case, if the issue is already listed here don\'t create a new one.","sidebar":"autoSidebar"}}}')}}]);